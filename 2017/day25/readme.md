Day 25 - The Halting Problem

Hmm, this was very much like [Day 22](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day22) in that my Haskell code should work, but runs into a stack overflow problem when I run it with `ghci`. But if I compile with optimizations (using `ghc -O`) then it runs fine, but takes about 20 seconds. The Python code runs in about 6.8 seconds.

Our input is a set of rules for a [Turing machine](https://en.wikipedia.org/wiki/Turing_machine). In Haskell, I parsed this based on the structure of the input, for Python I simply copied the Haskell output over as a dictionary (currently, it is set to the test input given in the [problem page](https://adventofcode.com/2017/day/25)).

To represent the tape, I thought of two things: either keep a list of nodes that are set to `1` or keep a dictionary/map object that contains the value of the nodes visited during the run. I tried both solutions (in both languages) and the list option is really slow. This is because of how lists are implemented; it takes a lot of time to keep adding and removing items from a list. On the other hand, dictionaries/mapping objects have much better access times and are easier to edit. In both languages, the dictionary is modified based on the rules and in the end I add up the values in the tape.

Haskell creates [thunks](https://wiki.haskell.org/Thunk) which are evaluated later on and I think this is the reason for the stack overflow because I'm running the Turing machine for `n` steps where `n` is a number with 8 digits. I did try to make things strict by putting an `!` before `new_pos, new_tape` but it didn't seem to do much. Running the program for 5000000 steps twice and then some more times actually manages to produce the correct answer, but I cannot run it 10000000 steps at once. Oh well.

---

And with that I have completed 2017's AoC. [Day 7](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day07) was pretty fun, so was [Day 9](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day09). I also liked implementing the knot hashing algorithm on [Day 10](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day10) (and this was improved upon on [Day 14](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day14)). The idea of building layers from a graph as on [Day 12](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day12) was reused a couple times. My favourite ones were [Day 16](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day16) with the dancing letters and [Day 21](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day21) with the fractal art. Thanks to [Day 5](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day05), [Day 22](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day22) and this one, I now know that compiling with optimizations can often lead to faster performance, but I should learn how to write more performant functions and try to be mindful about what's going on under the hood. And in the end, I had fun going into the system and rebooting the printer!