Day 21 - Fractal Art

Part two was surprisingly not computationally intensive. The difficulty was with parsing and programming the automaton. So, our input has a few rules that look like
```
../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#
```
Our machine is a square matrix made of `., #` characters. If the size is even, we break it up into chunks of `2x2` submatrices and replace each chunk with the rule. If not, then the size is divisible by `3` and we break up the machine into chunks of `3x3` submatrices and apply the rule on each submatrix. We always start with
```
.#.
..#
###
```
which is the [glider](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Game_of_Life)) from Conway's game of life. Our rules have two types: those that replace `2x2`-matrices with `3x3` ones and those that replace `3x3` ones with `4x4` ones, so the machine's size is always even or a multiple of 3.

There is one more thing. Not all rules are provided. We are allowed to rotate or flip the input matrix, i.e., if two states `A, B` are such that `B` is a rotation/flip of `A` then `A, B` are both replaced by the same rule even though the rule for `B` might not be in the input.

Parsing was easy, each line in the input has three `words` and only the first and last matter. Then I used `parse_string` to filter out the slashes and get hold of a matrix. And `parse_stream` does this for every line.

I then update my rulebook to include the rotated and flipped versions. The group of symmetries of a square is the [dihedral group](https://en.wikipedia.org/wiki/Dihedral_group) of order 8 and is generated by a rotation `r` of order 4 and a reflection `s` of order 2. Reflection is simply given by reversing each row of my matrix. Rotation is given by first reversing each row and then taking the transpose of the matrix. With this, I was able to get all transformations as in the `transformations` function. So, I `parse_stream` to get all the rules in the input, then get hold of all other rules by using `transformations` and finally `nub` to remove any repetitions and use `Map.fromList` to convert it into a `Data.Map` object.

Then there are the functions `break_into` and `rebuild`. These take a matrix and break it into chunks and take chunks and rebuild it into a matrix of a given size respectively. Both are pretty straightforward with recursion. Finally, `update` moves the automaton one stage forward based on its size.

For part one, we need to count the number of `#` characters (done using `count_lights`) after 5 generations. This ran pretty fast. For part two, we need to run the machine for 18 generations. I assumed this would take forever to run, but it was surprisingly quick. I'm glad because I really don't want to try and memoize this automaton. However, here is an observation: after 3 iterations, we get a `9x9` matrix made up of 9 smaller `3x3` matrices. The evolution of these 9 submatrices don't interact with each other, so we can keep track of the varieties of `3x3` matrices we see and jump ahead 3 generations at a time. Doing that would allow one to compute the number of lights in far futures. In any case, this was neat.