Day 23 - Coprocessor Conflagration

This was fairly simple. We have another assmebly code similar to [Day 18](https://github.com/shrivathsap/advent_of_code/tree/main/2017/day18), except the instructions are `set, sub, mul, jnz` where `set` sets a register, `sub` subtracts, `mul` multiplies and `jnz` is a jump instruction. We have 8 registers `a` through `h` all set to 0 initially. Part one asks us to count how many times `mul` is executed and is fairly simple.

I learnt something: `Map.insertWith f k a m` will replace the value of map `m` at key `k` with `f new_value old_value` where `new_value = a`. This means `Map.insertWith (-) k a m` will replace it with `a - old_value`. I assumed I would be subtracting `a` but that's not what was happening and I ended up with an infinite loop where the value in register `d` kept oscillating and skipping the exit condition. That's why I have `Map.insertWith (+)` instead. Before I figured this out, I wrote a quick `while` loop in Python to figure out what was going on because surely Haskell can't be _that_ slow!

In my Python code, I asked it to `print` the registers and I noticed that the register `d` was increasing by `1`, but before that `e` would increase from a small number all the way up to `b`. The exit condition for an inner loop was when `d = b`, but it would take over 50000 steps to reach that exit condition and this was for a pretty small value of `b`. Before that happens, the register `e` needs to get up to `b`.

In part two, the register `a` is set to `1` and we are to find out the value in register `h` after the program halts. Setting `a` to `1` triggers a jump instruction that skips a different jump instruction and lands us in a sequence of steps that make `b, c` huge. This means that we cannot wait for the program to halt and have to figure out what the assembly code is doing on our own. This reminded me of [Day 23 of 2016](https://github.com/shrivathsap/advent_of_code/tree/main/2016/day23) which also involved working out what the [assembunny code](https://adventofcode.com/2016/day/12) did.

So, here's what my input does. There are 8 registers and `a` is only used once - if nonzero it makes `b, c` huge. The register `h` is increased by `1` every time the register `f` is 0. The register `f` is set to `1` and is then set to `0` any time `g = b` after having set `g = d*e`. Other than that, `e` increases by `1` until it becomes `b` (and each time we check whether `b = d*e`), after that `d` is increased by `1` and we reset `e` to `2` and start counting.

If `d = b`, then we increase `h` if `f = 0`. After this we compare `b, c`. In part one these two were equal, but not in part two. If they are not equal, then `b` is increased by `17` and we repeat the whole thing from the top. In effect, `h` is counting the number of composite numbers in the sequence `b, b+17, b+17+17, ..., c`. I wrote a simple prime checking function and counted the number of composite numbers. Easy. I liked disassembling the assembly code.