Day 25 - Code Chronicle

And with that I've completed all 25 days. This puzzle was simple enough. There are a bunch of locks and keys given as a grid of `#, .`s with locks having a row of `#` at the top and keys having a row of `#` at the bottom. I lazily only looked whether the `(0,0)` position was `#` or not. After that we need to find how many pairs of locks and keys fit together, i.e., whether the number of `#` in the columns are small enough. An easy puzzle.

---

I had a lot of fun solving these puzzles, so many thanks to Eric and the team! I learnt a lot (Dijkstra's algorithm, caching, parsing grids), got comfortable with Haskell and thoroughly enjoyed solving the puzzles. Here are some puzzles that I enjoyed working on the most:

The hardest one was [Day 21](https://github.com/shrivathsap/advent_of_code/tree/main/2024/day21) about the layers of robots pressing keys. Even though it was hard, it was a very enjoyable thing to work through.

I suppose the second hardest on that comes to mind was [Day 11](https://github.com/shrivathsap/advent_of_code/tree/main/2024/day11) about Plutonian pebbles that double every time you blink. The trick was to store repetitions in a dictionary and this was very handy for some of the later days!

Two other puzzles that stand out are the reverse engineering ones: [Day 17](https://github.com/shrivathsap/advent_of_code/tree/main/2024/day17) about the chronospatial computer where I had to figure out what exactly my input was doing, and my favourite [Day 24](https://github.com/shrivathsap/advent_of_code/tree/main/2024/day24) about figuring out which wires in a binary adder were crossed. This was so much fun!! Reminded me about code breaking stories and such.

I entered this with low expectations about completing all 25 days, but each day I found myself looking forward to solving the puzzles. I am not a speed coder, nor do I care much about the global leaderboards; so I just wanted to solve and know that I could solve them. I had fun. Before the next event, I hope to try some of the past years. I want to try different languages (especially C), but I am really comfortable with Python; so if I'm doing it in real time, then that's my preferred language. To close,

this was a really fun 25 days of puzzle solving!