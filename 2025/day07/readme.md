Day 07 - Laboratories

With a little foresight, part two was just one line for me so that was pretty cool. Our input looks like
```
.......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```
The `S` indicates the source of tachyons and `^` indicate positions of beam splitters. A tachyon beam starts from `S` and proceeds downward. Every time it encounters a splitter, it splits into two - one going to the left of the splitter and another to the right. For part one we should find how many times the beam splits and for part two, we need to find all the number of paths the tachyon could take if we interpret the beam splitting in a quantum many-world sense (read the [problem page](https://adventofcode.com/2025/day/7) for a more detailed explanation).

I kind of expected part two to require such a count, so while solving part one, I made sure to keep track of the number of beams as well. So, in the example above, initially I have 1 beam at position `7`, after the third layer I have 1 beam at positions `6, 8`. After the fifth layer, I have `5->1, 7->2, 9->1` beams and so on. By the time I get to the bottom layer, the numbers indicate how many paths the tachyon could have taken to get to that position.

My program doesn't correct for the tachyons spilling out of bounds, but it turned out that I didn't need to - there is no spilling out of bounds.

Coming to the code, the main function is the `split_beams` function which takes in a list of lists of positions of the splitters, the initial beam configuration (seen as a `Data.Map` object sending positions to the number of beams at that position) and a count of how many splittings have happened. This function has two sub-functions:
- `adjust_pos` takes in the `beam_map` and a position to modify. It removes all beams at `pos` and adds them to `pos-1, pos+1` positions. Note that I didn't bother with going out of bounds because there are no splitters out of bounds. It turned out that it didn't matter, the input didn't have any splitters at the edges.
- `process_layer` takes in a layer of splitters, and adjusts the `beam_map` for every position where a splitting happens. It also increments the `count` variable. Adjusting happens by `foldl`ing on `adjust_pos`

Finally, I `foldl process_layer` along all the layers of splitters to get the final distribution of paths and the final count. When it came to the second part, I simply had to add the line `sum $ Map.elems final_dist` to get the answer.